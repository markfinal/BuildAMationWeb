<head>
<title>BuildAMation</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<H1>BuildAMation</H1>
<H2>What is BuildAMation?</H2>
<p>BuildAMation (Bam) is a build system and project generator written in C#, targetting at least version 4.0 (requires support for LINQ and lambda expressions). Familiarity with the C# language is assumed in this documentation.</p>
<p>Bam consists of a core assembly (Bam.Core.dll) that implements generic data structures and a dependency graph generation and evaluation algorithms. Specific implementation to compile and link code for programming languages, such as C and C++, specific toolchains, and other useful features, are provided in packages that extend the core infrastructure.</p>
<p>Bam can be used on Microsoft Windows (7+), Apple OSX (10.8+), and some Linux distributions (e.g. Ubuntu 14 and CentOS 7). OSX and Linux support for C# is provided through mono currently.</p>
<p>Bam packages contain C# code written in a declarative perspective. Therefore evaluation of the code is out of order from reading the scripts top-down. Packages can either provide new data structures/algorithms, or can use such definitions to describe how code can be built. Collections of packages can be grouped together logically into repositories. Each package requires a definition file (in XML) which defines all of it's dependencies.</p>
<p>Such algorithms provided by packages are build modes. By default, Bam provides four modes: Native, MakeFile, VSSolution, Xcode.</p>
<p>A command line tool, bam, is provided to execute packages. To build a package, change into the package directory, and run bam. That package is known as the master package. This also contains support to create a project for both VisualStudio or Xamarin Studio to debug package builds.</p>
<H2>Installation</H2>
<H3>Prerequisites</H3>
<H4>Windows</H4>
<ul>
<li>Windows 7, 8 or 8.1.</li>
<li>.NET framework 4 (includes C# compiler)</li>
<li>VisualStudio 2013 (Express)</li>
<li>TODO: MSDN download for .NET framework</lI>
</ul>
<H4>Apple OSX</H4>
<ul>
<li>OSX 10.8 (Mountain Lion), 10.9 (Mavericks), 10.10 (Yosemite)</li>
<li>Mono 4.0+</li>
<li>Xamarin Studio 5.9+</li>
<li>Xcode 4, 5, or 6.</li>
<li>TODO: mono-project.org website</li>
</ul>
<H4>Linux</H4>
<ul>
<li>Ubuntu 14+ or CentOS7+</li>
<li>Mono 4.0+</li>
<li>Xamarin Studio 5.9+</li>
<li>gcc/g++ 4.8</li>
<li>TODO: mono-project.org website</li>
</ul>
<H2>Key definitions</H2>
<H3>Package</H3>
<p>A package is a folder on disk, identified by a 'bam' subdirectory, an XML file in 'bam', and one or more files in a Script subfolder. A package defines classes or functions that implements modules.</p>
<H3>Package definition file</H3>
<p>A package definition file is an XML file, implementing the schema provided with Bam, defining the specific packages required in a build, Bam assemblies required, any additional .NET packages, and other compilation options. The first package definition file read is from the master package, and is allowed to define 'default' packages which can be used to resolve duplicate package requests.</p>
<H3>Module</H3>
<p>Modules are the build constructs of Bam. They are classes (sealed to be buildable, abstract/unsealed to define functionality), but there is no explicit instantiation of these classes. This is dealt with in the Bam core assembly. Modules can define how they are evaluated to determine whether they need building or not. Modules also define policies, dependent on the build mode, of how to execute when they do require building.</p>
<p>The C# scripts define classes within a namespace named after the containing package.</p>
<H3>Tool</H3>
<p>Tools are a type of module, but can be passed to build mode policies to be executed when building other modules. This does mean that tools can be procedurally generated as part of a build. Equally prebuilt tools, such as C/C++ compilers, can be used.</p>
<H3>Settings</H3>
<p>Settings are classes closely associated with tools. Each tool defines which settings can be assigned, per module, so that the execution of the tool for that module can be defined. Settings have defaults, but each module can override any default by applying a 'patch. A patch is implemented in terms of a lambda function. Bam defines two types of patches, public and private. Private, as the name suggests, is applied just to the build of the module. Public patches get applied both to the build of the module, and any module that has defined a dependency on it.</p>
<H3>Build mode</H3>
<p>The Bam build mode is the name of the policy to execute packages against. The core infrastructure does not have any dependency on specific build modes. Instead, implementations are discovered dynamically through reflection in the packages that are included in a build.</p>
<H3>Tokenized String</H3>
<p>Bam defines strings with markup called TokenizedStrings. These use specical syntax to identify tokens in the strings, so that parameterization is possible. The tokens are evaluated from macros from multiple sources; the main dependency graph (for global macros), per module, and custom macros.</p>
<H2>Running Bam</H2>
<p>Change the current directory to the package to be built (the master package).</p>
<H3>To create a debuggable project</H3>
<p>bam --createdebugproject</p>
<H3>To build in mode M</H3>
<p>bam -b=M</p>
<H2>Structure of a package</H2>
A package can be any folder on disk, usually containing source code. Identifying a Bam package is through additional files. This allows Bam to integrate into most existing projects. The steps to identify a Bam package are:
<ol>
<li>Package directory contains a subdirectory called 'bam'.</li>
<li>A single .xml file exists in the bam folder, and follows the Bam schema.</li>
<li>A Scripts folder exists in the bam folder, and contains one or more .cs files, containing module scripts.</li>
<li>Optional: Sibling folders to Scripts, named after the build modes supported.</li>
</ol>
TODO: example
<H2>Writing a module</H2>
Let's consider an example package called TestPackage. We will assume that dependent packages have already been defined in the package definition file for now.
<H3>A simple program</H3>
Define a module called MyProgram, which is a C (not C++) console application, with one source file, in the package directory called main.c.
<pre>
namespace TestPackage
{
  sealed class MyProgram :
    C.V2.ConsoleApplicaion
  {
     protected override void
     Init(
       Bam.Core.V2.Module parent)
     {
        base.Init(parent);
        this.CreateCContainer("$(pkgroot)/main.c");
     }
  }
}
</pre>
<H4>Points of interest</H4>
<ul>
<li>The namespace of the module is the name of the package it is in, TestPackage.</li>
<li>The name of the module is MyProgram, which is the name of the class.</li>
<li>The class is sealed, which is an indication to Bam that you want to build this.</li>
<li>MyProgram derives from C.V2.ConsoleApplication. This is a class from the C package, which defines the necessary infrastructure for compiling and linking a C console application.</li>
<li>The Init function is overridden from the base class. Init is used to define most of the properties of the module. The constructor is not used.</li>
<li>The Init function of the parent class is called first. Chaining the hierarchy in this way ensures that all properties of the infrastructure are always setup.</li>
<li>A method of the base class, CreateCContainer, is invoked, passing a TokenizedString. The underlying implementation evaluates the parameterized string, and creates additional modules, behind the scene, for each source file. In this case, there is only one, the file main.c in the package directory.</li>
</ul>
<H2>Advanced</H2>
Referenced modules (could these be sealed?)
Structure of graph
<H3>Writing a build mode extension</H3>
</body>
