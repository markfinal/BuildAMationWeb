<head>
<title>BuildAMation - build system and project generator</title>
<meta name="description" content="BuildAMation is a build system and project generator for C and C++ desktop applications, with an extensible architecture. It is written in C#, and works on Windows, Linux and Apple OSX. Build modes supported are a multithreaded native command line build, VisualStudio solution generation, Xcode workspace generation, and MakeFile generation. Packages extend the core infrastructure, and packages can be logically grouped into package repositories.">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
<style>
    body {background-color: #006600;}
 h1{
     font-family: 'Droid Serif', Georgia, Times, serif; 
     font-size: 16pt;
 }
 h2 {
     font-family: 'Droid Serif', Georgia, Times, serif;
     font-size: 14pt;
 }
 h3{
     font-family: 'Droid Serif', Georgia, Times, serif;
     font-size: 13pt;
 }
 h4{
     font-family: 'Droid Serif', Georgia, Times, serif;
     font-size: 12pt;
 }
 p{
     font-family: 'Droid Sans', Helvetica, Arial, sans-serif;
     font-size: 12pt;
 }
 ul{
     font-family: 'Droid Sans', Helvetica, Arial, sans-serif;
     font-size: 12pt;
 }
 li{
     font-family: 'Droid Sans', Helvetica, Arial, sans-serif;
     font-size: 12pt;
 }
 div{
     font-family: 'Droid Sans', Helvetica, Arial, sans-serif;
     font-size: 12pt;
 }
 #bootstrap-overrides 
 p{
     font-size:inherit;
 }
 #bootstrap-overrides 
 ul{
     font-size:inherit;
 }
  #bootstrap-overrides 
 li{
     font-family: 'Droid Sans', Helvetica, Arial, sans-serif;
     font-size:10pt;
 }
 </style>
</head>
<body>
 <div class="container">
       <div class="jumbotron" id="bootstrap-overrides">
    <a name="Top1"><img src="BAM.jpg" alt="BAM" align=right style="width:100px;height:100px;"></a>
    <h1 align="center">BuildAMation</h1>
    
            <a href="#where">Where to get BuildAMation?</a><BR>
            <a href="#whatis">What is BuildAMation?</a><BR>
            <a href="#installation">Installation</a><BR>
            <a href="#keydefs">Key Definitions</a><BR>
            <a href="#running">Running Bam</a><BR>
            <a href="#structure">Structure of Package</a><BR>
            <a href="#writing">Writing a Module</a><BR>
            <!--<a href="#advanced">Advanced</a><BR><BR>-->
            <a href="#otherrepos">Additional package repositories</a><BR>
            <a href="#contact">Contact</a><BR>

<a name="where"></a><H2>Where to get BuildAMation?</H2>
<p>BuildAMation is open source software, using the BSD 3-clause license, available from <a href="https://github.com/markfinal/BuildAMation">github</a>. You are free to fork the code, or download prebuilt releases. Prebuilt distributions function on all supported platforms.</p>
<H3>Current release</H3>
<p>The current release of BuildAMation is <a href="https://github.com/markfinal/BuildAMation/releases/tag/v1.0a2">1.0 alpha 2</a>.</p>
<a name="whatis"></a><H2>What is BuildAMation?</H2>
<p>BuildAMation (Bam) is a build system and project generator written in C#, targetting at least version 4.0 (requires support for LINQ and lambda expressions). Familiarity with the C# language is assumed in this documentation.</p>
<p>Bam consists of a core assembly (Bam.Core.dll) that implements generic data structures and dependency graph generation and evaluation algorithms. The specifics of compiling and linking code for programming languages, such as C and C++, toolchains on platforms (VisualC, Xcode, Gcc, etc), and other useful tasks to perform during a build of a software product, are provided in packages that extend the core infrastructure.</p>
<p>Bam can be used on Microsoft Windows (7+), Apple OSX (10.8+), and some Linux distributions (e.g. Ubuntu 14 and CentOS 7). OSX and Linux support for C# is provided through <a href="http://www.mono-project.com/">Mono</a> currently.</p>
<p>Bam packages contain C# declarative propositions in the form of classes, which each represent a 'module' to build. Evaluation of the modules is out of order from reading the scripts top-down. Packages can either provide new data structures/algorithms, or can use such definitions to describe how code can be built. Collections of packages can be grouped together logically into repositories. Each package requires a definition file (in XML) which defines all of it's dependencies.</p>
<p>Such algorithms provided by packages are build modes. By default, Bam provides four modes: Native (command line), MakeFile, VSSolution, Xcode.</p>
<p>Bam benefits from the strongly typed nature of C#. In a declarative scripting language, where instances of modules do not exist in those scripts (generally), references to modules are often made by type, and used in generics. Where possible, interfaces are used to abstract away niggly details. For example, compiler settings are abstracted in a suitably named C# property in an interface, and each compiler implementation understands how to translate the value of that property into it's syntax, either on the command line, or in a project script.</p>
<p>A command line tool, bam, is provided to execute packages. To build a package, run bam in its directory. That package is known as the <b>master package</b>. bam also contains support to create a project for both VisualStudio or Xamarin Studio to debug package builds.</p>
<H3>Competition</H3>
<p>The competitors to Bam that I know of are:</p>
<ul>
<li><a href="http://www.cmake.org/">CMake</li>
<li><a href="https://waf.io/">Waf</li>
</ul>
<a name="installation"></a><H2>Installation</H2>
<H3>Prerequisites</H3>
<p>These are the systems that have been used during testing.</p>
  <div class="row" id="bootstrap-overrides">
    <div class="col-sm-4" id="bootstrap-overrides">
      <h3>Windows</h3>
          <ul>
            <li>Windows 7, 8 or 8.1.</li>
            <li>.NET framework 4 (includes C# compiler)</li>
            <li>VisualStudio 2013 (Express)</li>
        </ul>
    </div>
    <div class="col-sm-4">
      <h3>Apple OSX</h3>
            <li>OSX 10.8 (Mountain Lion), 10.9 (Mavericks), 10.10 (Yosemite)</li>
            <li>Mono 4.0+</li>
            <li>Xamarin Studio 5.9+</li>
            <li>Xcode 4, 5, or 6.</li>
    </div>
    <div class="col-sm-4">
      <h3>Linux</h3>
            <li>Ubuntu 14 (some success on CentOS7 as well)</li>
            <li>Mono 4.0+</li>
            <li>Xamarin Studio 5.9+</li>
            <li>gcc/g++ 4.8</li>
    </div>
  </div>
  <p>Install Mono by following the <a href="http://www.mono-project.com/download/">Mono installation instructions</a>.</p>
<H3>Setting up your environment</H3>
<p>From a binary distribution, open a terminal to the extracted files, and on Linux or OSX (or Windows MSYS), run
<pre>source env.sh</pre>
or on Windows cmd prompt, run
<pre>env.bat</pre>
This will install Bam onto your PATH, and will show the details of the version of Bam on the console</p>
<p>From source, you can build Bam from the solution file, and run the tool through the IDE. This is useful if the core assembly needs to be updated. However, the general approach to using Bam is identical to that in the binary distribution. Note if you have compiled a debug version of the Core, then pass 'Debug' as an argument to the shell scripts mentioned above - the default is to use a 'Release' configuration.</p>
<H3>Trying Bam out</H3>
<p>The quickest way to try out Bam is to build the test cases. There is a test harness provided that uses Python 2. Change to the tests folder and type
<pre>python runtests.py -c debug</pre>
which will build all applicable tests on your platform using the Native build mode. See the help available from that Python script for more options.</p>
<p>Alternatively, change to one of the individual tests, and type the full Bam command line
<pre>bam -b=Native</pre>
Some tests have particular requirements, but most will build out of the box.</p>

 <a href="#Top1"><img src="TOP.jpg" alt="Top of Page" align=right></a>
<a name="keydefs"></a><H2>Key definitions</H2>
<H3>Package</H3>
<p>A package is a folder on disk, identified by a 'bam' subdirectory, an XML file under 'bam', and one or more files in a Script subfolder. A package defines classes or functions that implements modules.</p>
<H3>Package repository</H3>
<p>Bam defines a collection of packages to be a package repository. There is a default package repository provided with the Bam binary, and on github. There can be any number of repositories that you can download and use together to build up the required set of packages to build your software. A package repository consists of a <b>packages</b> folder, and optionally a <b>tests</b> folder, each containing Bam packages.</p>
<H3>Package definition file</H3>
<p>A package definition file is an XML file, implementing the schema provided with Bam, defining the package's name (and optionally version), the dependent packages required in a build, package repositories to search, Bam assemblies to reference, any additional .NET packages, and other compilation options. The first package definition file read is from the <b>master package</b>, and is allowed to define 'default' packages which can be used to resolve duplicate package requests.</p>
<H3>Module</H3>
<p>Modules are the first class citizens of what Bam uses to build software. They are classes (sealed to be buildable, abstract/unsealed to define functionality) defined in package scripts, but there is no explicit instantiation of these classes. This is dealt with in the Bam core assembly. Modules have methods that evaluate whether the code they reference is out of date. Modules also define policies, dependent on the build mode, of how to execute when they do require building.</p>
<p>The C# scripts define classes within a namespace, which is named after the name in the package definition file. Bam uses this name to search for modules within that package.</p>
<p>Almost everything is a module in the Bam world. So almost everything is buildable.</p>
<p>Dependencies are stated at the module level in package scripts. The basic module itself is only aware of two axiomatic principles - I depend on a module to be built before me, or I require this module to be present and up-to-date. Packages extend this by adding semantic meaning atop of the axioms by way of specific module functions, e.g. a C program must compile and link against a C static library, is coded in terms of the axioms.</p>
<H3>Tool</H3>
<p>Tools are a type of module, but can be referenced by build mode policies to be executed by other modules. This does mean that tools can be procedurally generated as part of a build. Equally prebuilt tools, such as C/C++ compilers, can be used.</p>
<H3>Settings</H3>
<p>Settings are classes closely associated with tools, which implement one or more <b>settings interface</b>. Each tool generically defines the settings that can be assigned (through interfaces). Each module has a copy of the settings for its tool, so that the execution of the tool can be tailored for that module. Settings have defaults, but each module can override any default by applying a <b>patch</b>. Additionally, the defaults can be modified prior to patching via a <b>site policy</b>, e.g. say your software must build as C++11, while the default Bam compilation mode is C++98, the site policy allows this to be changed for your software. A patch is implemented in terms of a lambda function. Bam defines two types of patches, public and private. Private, as the name suggests, is applied just to the build of the module. Public patches get applied both to the build of the module, and any module that has defined a dependency on it.</p>
<H3>Build mode</H3>
<p>The Bam build mode is the name of the policy to execute packages against. The core infrastructure does not have any dependency on specific build modes. Instead, implementations are discovered dynamically through reflection in the packages that are included in a build. Those build modes available are:</p>
<ul>
<li>Native - a command line build, that can use all available cores, and has implicit dependency checking for C compilation</li>
<li>MakeFile - generate a MakeFile for the build</li>
<li>VSSolution - generate VisualStudio projects and a solution for the build</li>
<li>Xcode - generate Xcode projects and a workspace for the build</li>
</ul>
<H3>Tokenized String</H3>
<p>Bam defines strings with markup called TokenizedStrings. These use specical syntax to identify tokens in the strings, so that parameterization is possible. The tokens are evaluated from macros from multiple sources; the main dependency graph (for global macros), per module, and custom macros.</p>
 <a href="#Top1"><img src="TOP.jpg" alt="Top of Page" align=right></a>
<a name="running"></a><H2>Running Bam</H2>
<p>Change the current directory to the package to be built (the master package).</p>
<H3>To create a debuggable project</H3>
<pre>bam --createdebugproject</pre>
<H3>Build using a particular mode</H3>
<pre>bam -b=mode</pre>
where mode is Native, MakeFile, VSSolution or Xcode.
<H3>More help</H3>
<p>There is built-in help in the Core assembly, as well as in packages offering command line options. The following command can be run in a package directory (in which case the packages used are inspected), or outside (in which case only the Core options are shown)</p>
<pre>bam --help</pre>
<a name="structure"></a><H2>Structure of a package</H2>
<p>A package can be any folder on disk, usually containing source code. Identifying a Bam package is through additional files. This allows Bam to integrate into most existing projects. The visual steps to identify a Bam package are:
<ol>
<li><p>Package directory contains a subdirectory called 'bam'.</p></li>
<li><p>A single .xml file exists in the bam folder, and follows the Bam schema.</p></li>
<li><p>A Scripts folder exists in the bam folder, and contains one or more .cs files, containing module scripts.</p></li>
<li><p>Optional: Sibling folders to Scripts, named after the build modes supported.</p></li>
</ol>
<p>See any of the packages in the Bam distribution for an example.</p>
 <a href="#Top1"><img src="TOP.jpg" alt="Top of Page" align=right></a>
<a name="writing"></a><H2>Writing a module</H2>
<p>Let's consider an example package called TestPackage. Suppose we have a directory 'TestPackage' containing a single source file main.c to build. We will assume that main.c contains some sensible C code to make an executable program, e.g. at least a main function. Note that for the benefit of this example, it s important to be C code, not C++, for example:</p>
<pre>
#include &lt;stdio.h&gt;

int main()
{
    printf("Hello world\n");
    return 0;
}
</pre>
<H3>Make a package</H3>
<p>Making a package is the first step to using Bam. Change into the TestPackage directory, and type
<pre>
bam --makepackage --pkgname=TestPackage
</pre>
This will create the bam folder, the package definition file, and a script file that just contains the TestPackage namespace.</p>
<H3>Add dependencies</H3>
<p>We intend to build some C code, so we need to pull in package dependencies that provide this support. Still in the TestPackage directory, type
<pre>
bam --adddependent --pkgname=C
bam --adddependent --pkgname=NativeBuilder
bam --adddependent --pkgname=VSSolutionBuilder
bam --adddependent --pkgname=MakeFileBuilder
bam --adddependent --pkgname=XcodeBuilder
bam --adddependent --pkgname=VisualC --pkgversion=12.0
bam --adddependent --pkgname=Gcc --pkgversion=4.8
bam --adddependent --pkgname=Clang --pkgversion=Apple425
</pre>
These commands have modified the package definition file. To view what it contains, run this command
<pre>
bam --showdefinition
</pre>
<H3>Create a debuggable project</H3>
<p>Now that all the dependencies are set up, you can create a debuggable project. Still in the TestPackage directory, type
<pre>
bam --createdebugproject
</pre>
The path to the project will be output to the console. Open this in either VisualStudio or Xamarin Studio.</p>
<p>You can browse the dependencies added, and the sources within them in the IDE. Debugging this project will also run Bam.</p>
<p>But for now, open up TestPackage.cs from within the TestPackage package in the solution explorer.</p>
<H3>A simple program</H3>
<p>In the script file created, define a module called MyProgram, which is a C (not C++) console application, with one source file, in the package directory called main.c. We will revisit a C++ source file later.</p>
<pre>
namespace TestPackage
{
  sealed class MyProgram :
    C.ConsoleApplication
  {
     protected override void
     Init(
       Bam.Core.Module parent)
     {
        base.Init(parent);
        this.CreateCSourceContainer("$(packagedir)/main.c");

        if (this.Linker is VisualCCommon.LinkerBase)
        {
            this.LinkAgainst&lt;WindowsSDK.WindowsSDK&gt;();
        }
     }
  }
}
</pre>
<H4>Points of interest</H4>
<ul>
<li>The namespace of the module is the name of the package it resides in, <em>TestPackage</em>.</li>
<li>The name of the module is <em>MyProgram</em>, which is the name of the class.</li>
<li>The class is sealed, which is an indication to Bam that you want to build this.</li>
<li>MyProgram derives from <em>C.ConsoleApplication</em>. This is a class from the C package (using the convention of package name as namespace), which defines the necessary infrastructure for compiling and linking a C console application.</li>
<li>The <em>Init</em> function is overridden from the base class. Init is used to define the properties of the module. The constructor is generally not used.</li>
<li>The Init function of the parent class is called first. Chaining the hierarchy in this way ensures that all properties of the infrastructure are always setup.</li>
<li>A method of the base class, <em>CreateCSourceContainer</em>, is invoked, passing string which is internally converted to a <em>TokenizedString</em>. The underlying implementation evaluates the parameterized string and, for this function, creates additional modules, behind the scene, for each source file. Wildcards can be used in the path to evaluate to more than one file. In this case, there is only one, the file main.c in the package directory.</li>
<li>The call to <em>LinkAgainst</em> is a generic function on the C.ConsoleApplication class, and required for building on Windows and VisualC, because the import libraries for system DLLs can only be found in the WindowsSDK. Without this, there is a linker error that kernel32.lib cannot be found. By calling this function, the Bam core requires that an instance of the module specified as the type argument exists, and is a non-build requirement of the program.</li>
</ul>
Now try to build the package
<pre>
bam -b=Native
</pre>
The result will be an executable in the build directory of the package.</p>
<H3>Private patch</H3>
<p>Private patches are applied solely to the build of the module they are applied to. In this example, a C preprocessor definition is added to the compilation of the source file.</p>
<pre>
namespace TestPackage
{
  sealed class MyProgram :
    C.ConsoleApplication
  {
     protected override void
     Init(
       Bam.Core.Module parent)
     {
        base.Init(parent);
        <mark>var sources =</mark> this.CreateCSourceContainer("$(packagedir)/main.c");
        <mark>sources.PrivatePatch(settings =>
          {
             var compiler = settings as C.ICommonCompilerSettings;
             compiler.PreprocessorDefines.Add("CUSTOM_DEFINE");
          });</mark>

        if (this.Linker is VisualCCommon.LinkerBase)
        {
            this.LinkAgainst&lt;WindowsSDK.WindowsSDK&gt;();
        }
     }
  }
}
</pre>
<H4>Points of interest</H4>
<ul>
<li>The return value of CreateCSourceContainer is now stored in a local variable. This is a container of all modules representing the compilation of source files. In this example, there is just one. Adding patches on the container affects <em>all</em> of the source files it contains.</li>
<li>Applying a private patch takes a lamba expression with a single argument, which is the settings object for the module on which it's applied.</li>
<li>Settings can then be cast into the interfaces which make up the module's settings class. For a private patch, as you know the module type it is applied to, you can guarantee which interfaces can be used. However, some tool specific interfaces won't be applicable to all uses, e.g. Gcc specific settings on a Windows build, so you may have check whether the interface is valid.</li>
<li>The <em>C.ICommonCompilerSettings</em> interface contains a property, <em>PreprocessorDefines</em>, allowing the module writer to manage preprocessor definitions in the build.</li>
</ul>
Now try to build the package
<pre>
bam -b=Native
</pre>
At this point, no modules will be rebuilt. Bam does not inspect for changed build settings between invocations, so a clean build is required to take on the updated settings.
<pre>
bam -b=Native -c
</pre>
However, if you inspect the command line output, you will see that CUSTOM_DEFINE is now passed as a preprocessor definition.</p>
<H3>Public patch</H3>
<p>Public patches are applied both to the build of the module they are applied to, and any dependents. A common case for this kind of patch is for a C library (static or dynamic) that has headers, and must expose an include search path to any other module that uses the library.</p>
<p>Here's an example of a static library, assuming library.c is present in the package directory and contains suitable code, and library.h is in an include folder in the package directory, e.g.</p>
<pre>
#ifndef LIBRARY_H
#define LIBRARY_H

extern void printme(const char *string);

#endif /* LIBRARY_H */
</pre>
<pre>
#include &lt;stdio.h&gt;

void printme(const char *string)
{
    printf("%s", string);
}
</pre>
<p>Here is the modified package script to include the build of the library</p>
<pre>
namespace TestPackage
{
  sealed class MyProgram :
    C.ConsoleApplication
  {
     ...
  }

  <mark>sealed class MyStaticLibrary :
      C.StaticLibrary
    {
        protected override void
        Init(
            Bam.Core.Module parent)
        {
            base.Init(parent);
            this.CreateCSourceContainer("$(packagedir)/library.c");
            this.PublicPatch((settings, appliedTo) =>
                {
                    var compiler = settings as C.ICommonCompilerSettings;
                    if (null != compiler)
                    {
                        compiler.IncludePaths.AddUnique(Bam.Core.TokenizedString.Create("$(packagedir)/include", this));
                    }
                });
        }
    }</mark>
}
</pre>
<H4>Points of interest</H4>
<ul>
<li>The name of the new module is <em>MyStaticLibrary</em>.</li>
<li>The base class of this new module is <em>C.StaticLibrary</em> to indicate that it is a static library.</li>
<li><em>PublicPatch</em> is the function called. But note that the function is now applied on <em>this</em>, rather then sources. The reason for this is that any dependency is written in terms of the module MyStaticLibrary, rather than on any source contained within it. Although the <em>public</em> patch is applied to <em>this</em>, because the C source container is <em>encapsulated</em> within MyStaticLibrary, the patch is applied to the source automatically.</li>
<li>Note also that PublicPatch lambdas take two arguments; <em>settings</em> as before, and now also <em>appliedTo</em>. The latter is the module on which the patch is being applied to. It may be useful to know which module the patch is being applied to; however, as in the example, <em>this</em> is usually the more useful module, to get the package directory of the source package, as opposed to using appliedTo which would get a different package directory.</li>
<li>Note the conditional on the cast of the settings. There's no meta data of where to direct public patches, so they are applied to a module's hierarchy of <em>child modules</em>, so can be applied equally to a link or compilation step.</li>
</ul>
<H3>Adding a dependency</H3>
<p>Now change the program, so that it makes use of the library, e.g. change main.c to </p>
<pre>
#include &lt;stdio.h&gt;
<mark>#include "library.h"</mark>

int main()
{
    <mark>printme("Hello world\n");</mark>
    return 0;
}
</pre>
<p>This requires the program to depend on the static library for both compilation (#include'ing the header) and for link (linking the function code). The C.ConsoleApplication module has a useful function to indicate how to do this.</p>
<pre>
namespace TestPackage
{
    sealed class MyProgram :
      C.ConsoleApplication
    {
        protected override void
        Init(
            Bam.Core.Module parent)
        {
            base.Init(parent);
            var sources = this.CreateCSourceContainer("$(packagedir)/main.c");
            sources.PrivatePatch(settings =>
            {
                var compiler = settings as C.ICommonCompilerSettings;
                compiler.PreprocessorDefines.Add("CUSTOM_DEFINE");
            });

            if (this.Linker is VisualCCommon.LinkerBase)
            {
                this.LinkAgainst&lt;WindowsSDK.WindowsSDK&gt;();
            }

            <mark>this.CompileAndLinkAgainst&lt;MyStaticLibrary&gt;(sources);</mark>
        }
    }

    sealed class MyStaticLibrary :
      C.StaticLibrary
    {
      ...
    }
}
</pre>
<H4>Points of interest</H4>
<ul>
<li><em>CompileAndLinkAgainst</em> is a generic function, that takes the dependent module type to specialize it, which Bam Core uses to set up low-level dependencies. As the function is called on <em>this</em>, and <em>this</em> is a program, this means a link dependency is set up. Bam Core is not aware of such a term as a link dependency, but it does know that the program depends on the static library to be up to date before the program can be up to date. Also, the function takes as an argument, the modules that compilation also have a dependency (as the function name suggests). A dependency is not required for compilation. However, any public patches from the dependent must be applied.</li>
<li>There are similar functions exposed on the C module base classes, such as <em>LinkAgainst</em> seen earlier, or compilation only (for header only libraries).</li>
</ul>
<p>Build the package once again, and you should see in the compiler console output that include paths are now included on both the program source and the library source.</p>
<H3>Trying other build modes</H3>
<p>In the examples above, we have used the Native build mode, to run command line builds of the package. Bam supports other types of build modes, applicable to different platforms. All the generated files are put into the build root, but each build mode will write to the console where the files can be found.</p>
<H4>Windows</H4>
<p>Generate a VisualStudio solution by running</p>
<pre>
bam -b=VSSolution -c
</pre>
<H4>Linux (and OSX)</H4>
<p>Generate a MakeFile by running</p>
<pre>
bam -b=MakeFile -c
</pre>
<p>The Makefile generated uses GNU make syntax, and not NMake that VisualStudio supports.</p>
<H4>OSX</H4>
<p>Generate an Xcode workspace by running</p>
<pre>
bam -b=Xcode -c
</pre>
<H3>C++ code</H3>
<p>The examples above all build C code. However, the C package understands more derivatives of the C language than just this. It understands C++, ObjectiveC and ObjectiveC++. Bam uses the type of the module to determine which language it is using. For example, as shown above, a C program uses the base type
<pre>
C.ConsoleApplication
</pre>
For a program that uses C++ code, and requires the C++ linker, this would be
<pre>
C.Cxx.ConsoleApplication
</pre>
Similarly, for source code, instead of
<pre>
this.CreateCSourceContainer()
</pre>
use
<pre>
this.CreateCxxSourceContainer()
</pre>
in order to use the C++ compiler for the toolchain.</p>
<p>It is also possible, and sometimes required, to create multiple source containers, from different languages. Ensure that you always link with the correct module type in order to use the right linker for your code.</p>
<!--
<a name="advanced"></a><H2>Advanced</H2>
<p>TODO
Referenced modules (could these be sealed?)
Structure of graph</p>
<H3>Writing a build mode extension</H3>
<p>TODO</p>
-->
<a name="otherrepos"></a><H2>Additional Package Repositories</H2>
<p>Although Bam has a default package repository with functionality to get you started, there are other software packages and tools that exist that would benefit from being included as a Bam package. Some additional package repositories exist, that offer the Bam build scripts for you to include in your own software builds.<p>
<ul>
<li><a href="https://github.com/markfinal/bam-qt">bam-qt</a> - Qt 4.8.5 and Qt 5.3.2, including the moc tool.</li>
<li><a href="https://github.com/markfinal/bam-graphicssdk">bam-graphicssdk</a> - Direct3D, OpenGL, GLEW</li>
<li><a href="https://github.com/markfinal/bam-zeromq">bam-zeromq</a> - ZeroMQ library build, and test</li>
<li><a href="https://github.com/markfinal/bam-xml">bam-xml</a> - TinyXML2 library build</li>
</ul>
<p>It is encouraged that anyone can provide and publish a package repository.</p>
<BR>
<a name="contact"></a><H2>Contact</H2>
<p>If you would like to contact me about BuildAMation, please email me on the address below. I am happy to provide advice to free software developers where my time allows.</p>
<p>For any commercial use, please contact me to discuss further.</p>
<p>Contact details: <a href=mailto:markfinal@hotmail.com>markfinal@hotmail.com</a>
     <a href="#Top1"><img src="TOP.jpg" alt="Top of Page" align=right></a>
  </div>
</div>
</body>
