<head>
<title>BuildAMation</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
<style>
    body {background-color: #006600;}
 h1{
     font-family: 'Droid Serif', Georgia, Times, serif; 
	 font-size: 16pt;
 }
 h2 {
	 font-family: 'Droid Serif', Georgia, Times, serif;
	 font-size: 14pt;
 }
 h3{
	 font-family: 'Droid Serif', Georgia, Times, serif;
	 font-size: 13pt;
 }
 h4{
	 font-family: 'Droid Serif', Georgia, Times, serif;
	 font-size: 12pt;
 }
 p{
     font-family: 'Droid Sans', Helvetica, Arial, sans-serif;
	 font-size: 12pt;
 }
 ul{
     font-family: 'Droid Sans', Helvetica, Arial, sans-serif;
	 font-size: 12pt;
 }
 li{
     font-family: 'Droid Sans', Helvetica, Arial, sans-serif;
	 font-size: 12pt;
 }
 div{
     font-family: 'Droid Sans', Helvetica, Arial, sans-serif;
	 font-size: 12pt;
 }
 #bootstrap-overrides 
 p{
	 font-size:inherit;
 }
 #bootstrap-overrides 
 ul{
	 font-size:inherit;
 }
  #bootstrap-overrides 
 li{
	 font-family: 'Droid Sans', Helvetica, Arial, sans-serif;
	 font-size:10pt;
 }
 </style>
</head>
<body>
 <div class="container">
	   <div class="jumbotron" id="bootstrap-overrides">
    <a name="Top1"><img src="BAM.jpg" alt="BAM" align=right style="width:100px;height:100px;"></a>
	<h1 align="center">BuildAMation</h1>
	
	        <a href="#whatis">What is BuildAMation?</a><BR>
	        <a href="#installation">Installation</a><BR>
	        <a href="#keydefs">Key Definitions</a><BR>
			<a href="#running">Running Bam</a><BR>
			<a href="#structure">Structure of Package</a><BR>
			<a href="#writing">Writing a Module</a><BR>
			<a href="#advanced">Advanced</a><BR><BR>

<a name="whatis"></a><H2>What is BuildAMation?</H2>
<p>BuildAMation (Bam) is a build system and project generator written in C#, targetting at least version 4.0 (requires support for LINQ and lambda expressions). Familiarity with the C# language is assumed in this documentation.</p>
<p>Bam consists of a core assembly (Bam.Core.dll) that implements generic data structures and a dependency graph generation and evaluation algorithms. Specific implementation to compile and link code for programming languages, such as C and C++, specific toolchains, and other useful features, are provided in packages that extend the core infrastructure.</p>
<p>Bam can be used on Microsoft Windows (7+), Apple OSX (10.8+), and some Linux distributions (e.g. Ubuntu 14 and CentOS 7). OSX and Linux support for C# is provided through mono currently.</p>
<p>Bam packages contain C# code written in a declarative perspective. Therefore evaluation of the code is out of order from reading the scripts top-down. Packages can either provide new data structures/algorithms, or can use such definitions to describe how code can be built. Collections of packages can be grouped together logically into repositories. Each package requires a definition file (in XML) which defines all of it's dependencies.</p>
<p>Such algorithms provided by packages are build modes. By default, Bam provides four modes: Native, MakeFile, VSSolution, Xcode.</p>
<p>A command line tool, bam, is provided to execute packages. To build a package, change into the package directory, and run bam. That package is known as the master package. This also contains support to create a project for both VisualStudio or Xamarin Studio to debug package builds.</p>
<a name="installation"></a><H2>Installation</H2>
<H3>Prerequisites</H3>
  <div class="row" id="bootstrap-overrides">
    <div class="col-sm-4" id="bootstrap-overrides">
      <h3>Windows</h3>
	  	<ul>
			<li>Windows 7, 8 or 8.1.</li>
			<li>.NET framework 4 (includes C# compiler)</li>
			<li>VisualStudio 2013 (Express)</li>
			<li>TODO: MSDN download for .NET framework</lI>
		</ul>
    </div>
    <div class="col-sm-4">
      <h3>Apple OSX</h3>
	  		<li>OSX 10.8 (Mountain Lion), 10.9 (Mavericks), 10.10 (Yosemite)</li>
			<li>Mono 4.0+</li>
			<li>Xamarin Studio 5.9+</li>
			<li>Xcode 4, 5, or 6.</li>
			<li>TODO: mono-project.org website</li>
    </div>
    <div class="col-sm-4">
      <h3>Linux</h3>
	  		<li>Ubuntu 14+ or CentOS7+</li>
			<li>Mono 4.0+</li>
			<li>Xamarin Studio 5.9+</li>
			<li>gcc/g++ 4.8</li>
			<li>TODO: mono-project.org website</li>
    </div>
  </div>
  

 <a href="#Top1"><img src="TOP.jpg" alt="Top of Page" align=right></a>
<a name="keydefs"></a><H2>Key definitions</H2>
<H3>Package</H3>
<p>A package is a folder on disk, identified by a 'bam' subdirectory, an XML file in 'bam', and one or more files in a Script subfolder. A package defines classes or functions that implements modules.</p>
<H3>Package definition file</H3>
<p>A package definition file is an XML file, implementing the schema provided with Bam, defining the specific packages required in a build, Bam assemblies required, any additional .NET packages, and other compilation options. The first package definition file read is from the master package, and is allowed to define 'default' packages which can be used to resolve duplicate package requests.</p>
<H3>Module</H3>
<p>Modules are the build constructs of Bam. They are classes (sealed to be buildable, abstract/unsealed to define functionality), but there is no explicit instantiation of these classes. This is dealt with in the Bam core assembly. Modules can define how they are evaluated to determine whether they need building or not. Modules also define policies, dependent on the build mode, of how to execute when they do require building.</p>
<p>The C# scripts define classes within a namespace named after the containing package.</p>
<p>Almost everything is a module in the Bam world.</p>
<H3>Tool</H3>
<p>Tools are a type of module, but can be passed to build mode policies to be executed when building other modules. This does mean that tools can be procedurally generated as part of a build. Equally prebuilt tools, such as C/C++ compilers, can be used.</p>
<H3>Settings</H3>
<p>Settings are classes closely associated with tools, which are made up of one or more interfaces. Each tool defines which settings can be assigned (through an interface), per module, so that the execution of the tool for that module can be defined. Settings have defaults, but each module can override any default by applying a 'patch. A patch is implemented in terms of a lambda function. Bam defines two types of patches, public and private. Private, as the name suggests, is applied just to the build of the module. Public patches get applied both to the build of the module, and any module that has defined a dependency on it.</p>
<H3>Build mode</H3>
<p>The Bam build mode is the name of the policy to execute packages against. The core infrastructure does not have any dependency on specific build modes. Instead, implementations are discovered dynamically through reflection in the packages that are included in a build.</p>
<H3>Tokenized String</H3>
<p>Bam defines strings with markup called TokenizedStrings. These use specical syntax to identify tokens in the strings, so that parameterization is possible. The tokens are evaluated from macros from multiple sources; the main dependency graph (for global macros), per module, and custom macros.</p>
 <a href="#Top1"><img src="TOP.jpg" alt="Top of Page" align=right></a>
<a name="running"></a><H2>Running Bam</H2>
<p>Change the current directory to the package to be built (the master package).</p>
<H3>To create a debuggable project</H3>
<pre>bam --createdebugproject</pre>
<H3>To build in mode M</H3>
<pre>bam -b=M</pre>
<a name="structure"></a><H2>Structure of a package</H2>
<p>A package can be any folder on disk, usually containing source code. Identifying a Bam package is through additional files. This allows Bam to integrate into most existing projects. The steps to identify a Bam package are:
<ol>
<li><p>Package directory contains a subdirectory called 'bam'.</p></li>
<li><p>A single .xml file exists in the bam folder, and follows the Bam schema.</p></li>
<li><p>A Scripts folder exists in the bam folder, and contains one or more .cs files, containing module scripts.</p></li>
<li><p>Optional: Sibling folders to Scripts, named after the build modes supported.</p></li>
</ol>
<p>TODO: example</p>
 <a href="#Top1"><img src="TOP.jpg" alt="Top of Page" align=right></a>
<a name="writing"></a><H2>Writing a module</H2>
<p>Let's consider an example package called TestPackage. We will assume that dependent packages have already been defined in the package definition file for now.</p>
<H3>A simple program</H3>
<p>Define a module called MyProgram, which is a C (not C++) console application, with one source file, in the package directory called main.c.</p>
<pre>
namespace TestPackage
{
  sealed class MyProgram :
    C.V2.ConsoleApplicaion
  {
     protected override void
     Init(
       Bam.Core.V2.Module parent)
     {
        base.Init(parent);
        this.CreateCContainer("$(pkgroot)/main.c");
     }
  }
}
</pre>
<H4>Points of interest</H4>
<ul>
<li>The namespace of the module is the name of the package it is in, TestPackage.</li>
<li>The name of the module is MyProgram, which is the name of the class.</li>
<li>The class is sealed, which is an indication to Bam that you want to build this.</li>
<li>MyProgram derives from C.V2.ConsoleApplication. This is a class from the C package, which defines the necessary infrastructure for compiling and linking a C console application.</li>
<li>The Init function is overridden from the base class. Init is used to define most of the properties of the module. The constructor is not used.</li>
<li>The Init function of the parent class is called first. Chaining the hierarchy in this way ensures that all properties of the infrastructure are always setup.</li>
<li>A method of the base class, CreateCContainer, is invoked, passing a TokenizedString. The underlying implementation evaluates the parameterized string, and creates additional modules, behind the scene, for each source file. Wildcards can be used. In this case, there is only one, the file main.c in the package directory.</li>
</ul>
<H3>Private patch</H3>
<p>Private patches are applied solely to the build of the module they are applied to. In this example, a C preprocessor definition is added to the compilation of the source file.</p>
<pre>
namespace TestPackage
{
  sealed class MyProgram :
    C.V2.ConsoleApplicaion
  {
     protected override void
     Init(
       Bam.Core.V2.Module parent)
     {
        base.Init(parent);
        <mark>var sources =</mark> this.CreateCContainer("$(pkgroot)/main.c");
        <mark>sources.PrivatePatch(settings =>
          {
             var compiler = settings as C.V2.ICommonCompilerOptions;
             compiler.PreprocessorDefinitions.Add("CUSTOM_DEFINE");
          });</mark>
     }
  }
}
</pre>
<H4>Points of interest</H4>
<ul>
<li>The return value of CreateCContainer is now stored in a local variable. This is a container of all modules representing the compilation of source files. In this example, there is just one. Making patches on settings on the container affect all of the source files it contains.</li>
<li>Applying a private patch takes a lamba expression with a single argument, which is the settings for the module on which it's applied.</li>
<li>Settings can then be cast into the interfaces which make up the module's settings instance. For a private patch, as you know the module type it is applied to, you can guarantee which interfaces can be in use. However, some tool specific interfaces won't be applicable to all uses, e.g. Gcc specific settings, so you may have check whether the interface is valid.</li>
<li>The C.V2.ICommonCompilerOptions contains a property, PreprocessorDefinitions, allowing the module writer to add preprocessor definitions to the build.</li>
</ul>
<H3>Public patch</H3>
<p>Public patches are applied both to the build of the module they are applied to, and any dependents. A common case for this kind of patch is for a C library (static or dynamic) that has headers, and must expose an include search path. Here's an example of a static library.</p>
<pre>
namespace TestPackage
{
  sealed class MyStaticLibrary :
    C.V2.StaticLibrary
  {
     protected override void
     Init(
       Bam.Core.V2.Module parent)
     {
        base.Init(parent);
        var sources = this.CreateCContainer("$(pkgroot)/library.c");
        this.PublicPatch((settings, appliedTo) =>
          {
             var compiler = settings as C.V2.ICommonCompilerOptions;
             if (null != compiler)
             {
                compiler.IncludePaths.Add(Bam.Core.V2.TokenizedString("$(pkgroot)/include", this);
             }
          });
     }
  }
}
</pre>
<H4>Points of interest</H4>
<ul>
<li>The name of the class is now MyStaticLibrary as it represents a new module.</li>
<li>The base class has now changed to C.V2.StaticLibrary to indicate what sort of module it is.</li>
<li>PublicPatch is the function called. But note that this is now applied on this, rather then sources. The reason for this is that a dependency is made onto the module MyStaticLibrary, rather than on any source contained within it.</li>
<li>Note the conditional on the cast of the settings. There's no meta data of where to direct public patches, so they are applied to a module's hierarchy of modules.</li>
</ul>
<a name="advanced"></a><H2>Advanced</H2>
<p>TODO
Referenced modules (could these be sealed?)
Structure of graph</p>
<H3>Writing a build mode extension</H3>
<p>TODO</p>
<BR>
<p>Contact details: <a href=mailto:markfinal@hotmail.com>markfinal@hotmail.com</a>
	 <a href="#Top1"><img src="TOP.jpg" alt="Top of Page" align=right></a>
  </div>
</div>
</body>
